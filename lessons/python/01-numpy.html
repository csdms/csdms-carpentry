<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="pandoc">
    <title>Software Carpentry: Programming with Python</title>
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="css/swc.css" />
    <meta charset="UTF-8" />
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body class="lesson">
    <div class="container card">
      <div class="banner">
        <a href="http://csdms.colorado.edu" title="Community Surface Dynamics Modeling System">
          <img alt="CSDMS banner" src="img/CSDMS_banner.png" />
        </a>
      </div>
      <article>
      <div class="row">
        <div class="col-md-10 col-md-offset-1">
                    <a href="index.html"><h1 class="title">Programming with Python</h1></a>
          <h2 class="subtitle">Analyzing Topographic data</h2>
          <section class="objectives panel panel-warning">
<div class="panel-heading">
<h2 id="learning-objectives"><span class="glyphicon glyphicon-certificate"></span>Learning Objectives</h2>
</div>
<div class="panel-body">
<ul>
<li>Explain what a library is, and what libraries are used for</li>
<li>Load a Python library and use the tools it contains</li>
<li>Read data from a file into a program</li>
<li>Assign values to variables</li>
<li>Select individual values and subsections from data</li>
<li>Perform operations on arrays of data</li>
<li>Display simple graphs</li>
</ul>
</div>
</section>
<p>While a lot of powerful tools are built into languages like Python, even more tools exist in <a href="reference.html#library">libraries</a>.</p>
<p>In order to load the elevation data, we need to <a href="reference.html#import">import</a> a library called NumPy. You should use this library if you want to do fancy things with numbers (ie. math), especially if you have matrices or arrays. We can load NumPy using:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy</code></pre></div>
<p>Importing a library is like pulling a toolbox out of a storage locker and placing it on your workbench, making everything inside the toolbox accessible. Python has a set of built-in functions that are always available (the tools you always have available) and libraries provide additional functionality (the specialized tools in the toolbox you only sometimes need).</p>
<p>Once we’ve loaded the library, we can call a function inside that library to read the data file:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">numpy.loadtxt(fname<span class="op">=</span><span class="st">&#39;data/topo.asc&#39;</span>, delimiter<span class="op">=</span><span class="st">&#39;,&#39;</span>)</code></pre></div>
<pre class="output"><code>array([[ 3198.8391,  3198.123 ,  3197.1584, ...,  2583.3293, 
    2585.4368, 2589.1079], [ 3198.3306,  3197.5242,  3196.4102, ..., 
    2582.6992,  2584.9167, 2587.801 ], [ 3197.9968,  3196.9197, 
    3195.7188, ...,  2581.8328,  2583.8159, 2586.0325], ..., [
    3325.1509,  3334.7822,  3343.3154, ...,  2780.8191,  2769.3235,
    2762.373 ], [ 3325.0823,  3335.0308,  3345.4963, ...,  2775.3345, 
    2765.7131, 2759.6555], [ 3326.6824,  3336.5305,  3348.1343, ..., 
    2769.7661,  2762.5242, 2756.6877]])</code></pre>
<p>The expression <code>numpy.loadtxt(...)</code> is a <a href="reference.html#function-call">function call</a> that asks Python to run the function <code>loadtxt</code> that belongs to the <code>numpy</code> library. This <a href="reference.html#dotted-notation">dotted notation</a>, with the syntax <code>thing.component</code>, is used everywhere in Python to refer to parts of things.</p>
<p>The function call to <code>numpy.loadtxt</code> has two <a href="reference.html#parameter">parameters</a>: the name of the file we want to read, and the <a href="reference.html#delimiter">delimiter</a> that separates values on a line. Both need to be character strings (or <a href="reference.html#string">strings</a>, for short) so we write them in quotes.</p>
<p>Within the Jupyter (iPython) notebook, pressing Shift+Enter runs the commands in the selected cell. Because we haven’t told iPython what to do with the output of <code>numpy.loadtxt</code>, the notebook just displays it on the screen. In this case, that output is the data we just loaded. By default, only a few rows and columns are shown (with <code>...</code> to omit elements when displaying big arrays).</p>
<p>Our call to <code>numpy.loadtxt</code> read the file but didn’t save it to memory. In order to access the data, we need to <a href="reference.html#assignment">assign</a> the values to a <a href="reference.html#variable">variable</a>. A variable is just a name that refers to an object. Python’s variables must begin with a letter and are <a href="reference.html#case-sensitive">case sensitive</a>. We can assign a variable name to an object using <code>=</code>.</p>
<aside class="callout panel panel-info">
<div class="panel-heading">
<h2 id="objects-and-their-names"><span class="glyphicon glyphicon-pushpin"></span>Objects and their names</h2>
</div>
<div class="panel-body">
<p>What happens when a function is called but the output is not assigned to a variable is a bit more complicated than simply not saving it. The call to <code>numpy.loadtxt</code> read the file and created an object in memory that contains the data, but because we didn’t assign it to a variable name, there is no way for us to call this object. While this difference might seem irrelevant (and, in practice, it probably is), it will be important to consider how variable names are assigned to objects when we talk about mutable and immutable objects later on.</p>
<p>A good explanation of how Python handles variables and objects can be found [in Jeff Knupp’s blog]. (https://jeffknupp.com/blog/2012/11/13/is-python-callbyvalue-or- callbyreference-neither/)</p>
</div>
</aside>
<p>Let’s re-run numpy.loadtxt and assign the output to a variable name:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">topo <span class="op">=</span> numpy.loadtxt(<span class="st">&#39;topo.asc&#39;</span>, delimiter<span class="op">=</span><span class="st">&#39;,&#39;</span>)</code></pre></div>
<p>This command doesn’t produce any visible output. If we want to see the data, we can print the variable’s value with the command <code>print</code>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span> topo</code></pre></div>
<pre class="output"><code>    [[ 3198.8391  3198.123   3197.1584 ...,  2583.3293  2585.4368 
    2589.1079] [ 3198.3306  3197.5242  3196.4102 ...,  2582.6992 
    2584.9167  2587.801 ] [ 3197.9968  3196.9197  3195.7188 ..., 
    2581.8328  2583.8159  2586.0325] ..., [ 3325.1509  3334.7822 
    3343.3154 ...,  2780.8191  2769.3235  2762.373 ] [ 3325.0823 
    3335.0308  3345.4963 ...,  2775.3345  2765.7131  2759.6555] [
    3326.6824  3336.5305  3348.1343 ...,  2769.7661  2762.5242 
    2756.6877]]</code></pre>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="check-your-understanding"><span class="glyphicon glyphicon-pencil"></span>Check your understanding</h2>
</div>
<div class="panel-body">
<p>Track how variable names and values are connected after each statement in the following program:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">mass <span class="op">=</span> <span class="fl">47.5</span>
age <span class="op">=</span> <span class="dv">122</span>
mass <span class="op">=</span> mass <span class="op">*</span> <span class="fl">2.0</span>
age <span class="op">=</span> age <span class="op">-</span> <span class="dv">20</span></code></pre></div>
</div>
</section>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="sorting-out-references"><span class="glyphicon glyphicon-pencil"></span>Sorting out references</h2>
</div>
<div class="panel-body">
<p>What does the following program print out?</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">first, second <span class="op">=</span> <span class="st">&#39;Grace&#39;</span>, <span class="st">&#39;Hopper&#39;</span>
third, fourth <span class="op">=</span> second, first
<span class="bu">print</span> third, fourth</code></pre></div>
</div>
</section>
<p>Using its variable name, we can see that <a href="reference.html#type">type</a> of object the variable name <code>topo</code> is assigned to:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span> <span class="bu">type</span>(topo)</code></pre></div>
<pre class="output"><code>    &lt;type &#39;numpy.ndarray&#39;&gt;</code></pre>
<p>The function <code>type</code> tells us that the variable name <code>topo</code> currently points to an N-dimensional array created by the NumPy library. We can also get the shape of the array:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span> topo.shape</code></pre></div>
<pre class="output"><code>(500, 500)</code></pre>
<p>This tells us that <code>topo</code> has 500 rows and 500 columns. The file we imported contains elevation data (in meters, 2 degree spacing) for an area along the Front Range of Colorado, so the area that this array represents is 1 km x 1 km.</p>
<p>The object of type <code>numpy.ndarray</code> that the variable <code>topo</code> is assigned to contains the values of the array as well as some extra information about the array. These are the <a href="reference.html#member">members</a> or attributes of the object, and they describe the data in the same way an adjective describes a noun. The command <code>topo.shape</code> calls the <code>shape</code> attribute of the object with the variable name <code>topo</code> that describes its dimensions. We use the same dotted notation for the attributes of objects that we use for the functions inside libraries because they have the same part-and-whole relationship.</p>
<aside class="callout panel panel-info">
<div class="panel-heading">
<h2 id="len-and-other-built-in-functions"><span class="glyphicon glyphicon-pushpin"></span>len() and other built-in functions</h2>
</div>
<div class="panel-body">
<p>The function <code>len()</code> returns the length of the longest axis of a sequence (a numpy array, a list, etc.). Because it is a built-in function, it is always available for the Python interpreter and doesn’t have to be imported. The function <code>type()</code> is another built in function. You can read about them in the [Python docs]. (https://docs.python.org/2/library/functions.html)</p>
</div>
</aside>
<aside class="callout panel panel-info">
<div class="panel-heading">
<h2 id="whos-who-in-the-memory"><span class="glyphicon glyphicon-pushpin"></span>Who’s who in the memory</h2>
</div>
<div class="panel-body">
<p>You can use the whos command at any time to see what variables you have created and what modules you have loaded into the computers memory. As this is an IPython command, it will only work if you are in an IPython terminal or the Jupyter Notebook.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">whos</code></pre></div>
<pre class="output"><code>Variable    Type       Data/Info
--------------------------------
numpy       module     &lt;module &#39;numpy&#39; from &#39;/Us&lt;...&gt;kages/numpy/__init__.py&#39;&gt;
topo        ndarray    500x500:250000 elems, type `float64`, 2000000 bytes (1 Mb)</code></pre>
</div>
</aside>
<h2 id="plotting">Plotting</h2>
<p>Rasters are just big two dimensional arrays of values. In the case of DEMs, those values are elevations. It’s very hard to get a good sense of what this landscape looks like by looking directly at the data. This information is better conveyed through plots and graphics.</p>
<p>Data visualization deserves an entire lecture (or course) of its own, but we can explore a few features of Python’s <code>matplotlib</code> library here. While there is no “official” plotting library in Python, this package is the de facto standard.</p>
<p>We start by importing the <code>pyplot</code> module from the library <code>matplotlib</code>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> matplotlib.pyplot</code></pre></div>
<aside class="callout panel panel-info">
<div class="panel-heading">
<h2 id="some-ipython-magic"><span class="glyphicon glyphicon-pushpin"></span>Some IPython magic</h2>
</div>
<div class="panel-body">
<p>If you’re using an IPython / Jupyter notebook, you’ll need to execute the following command in order for the plots to appear in the notebook instead of a separate window:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="op">%</span>matplotlib inline</code></pre></div>
<p>The <code>%</code> indicates an IPython magic function - a function that is only valid within the notebook environment. Note that you only have to execute this function once per notebook.</p>
</div>
</aside>
<p>We can use the function <code>imshow</code> within <code>matplotlib.pyplot</code> to display arrays as a 2D image:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">matplotlib.pyplot.imshow(topo)</code></pre></div>
<pre class="output"><code>![png](fig/output_24_1.png)</code></pre>
<h2 id="indexing">Indexing</h2>
<p>We can access individual values in an array using an <a href="reference.html#index">index</a> in square brackets:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span> <span class="st">&#39;elevation at the corner of topo:&#39;</span>, topo[<span class="dv">0</span>,<span class="dv">0</span>], <span class="st">&#39;meters&#39;</span></code></pre></div>
<pre class="output"><code>elevation at the corner of topo: 3198.8391 meters</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span> <span class="st">&#39;elevation at some random point in topo:&#39;</span>, topo[<span class="dv">137</span>,<span class="dv">65</span>],
<span class="co">&#39;meters&#39;</span></code></pre></div>
<pre class="output"><code>elevation at some random spot in topo: 3251.1179 meters</code></pre>
<p>When referring to entries in a two dimensional array, the indices are ordered <code>[row,column]</code>. The expression <code>topo[137, 65]</code> should not surprise you but <code>topo[0,0]</code> might. Programming languages like Fortran and MATLAB start counting at 1 because that’s what (most) humans have done for thousands of years. Languages in the C family (including C++, Java, Perl, and Python) count from 0 because that’s simpler for computers to do. So if we have an M×N array in Python, the indices go from 0 to M-1 on the first axis (rows) and 0 to N-1 on the second (columns). In MATLAB, the same array (or matrix) would have indices that go from 1 to M and 1 to N. Zero-based indexing takes a bit of getting used to, but one way to remember the rule is that the index is how many steps we have to take from the start to get to the item we want.</p>
<p>Python also allows for negative indices to refer to the position of elements with respect to the end of each axis. An index of -1 refer to the last item in a list, -2 is the second to last, and so on. Since index <code>[0,0]</code> is the upper left corner of an array, index <code>[-1,-1]</code> therefore the lower right corner of the array:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span> topo[<span class="op">-</span><span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>]</code></pre></div>
<pre class="output"><code>2756.6877</code></pre>
<aside class="callout panel panel-info">
<div class="panel-heading">
<h2 id="in-the-corner"><span class="glyphicon glyphicon-pushpin"></span>In the Corner</h2>
</div>
<div class="panel-body">
<p>What may also surprise you is that when Python displays an array, it shows the element with index <code>[0, 0]</code> in the upper left corner rather than the lower left. This is consistent with the way mathematicians draw matrices, but different from the Cartesian coordinates. The indices are (row, column) instead of (column, row) for the same reason, which can be confusing when plotting data.</p>
</div>
</aside>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="check-your-understanding-1"><span class="glyphicon glyphicon-pencil"></span>Check your understanding</h2>
</div>
<div class="panel-body">
<p>Draw diagrams showing how variable names and values are connected after each statement in the following program:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">mass <span class="op">=</span> <span class="fl">47.5</span>
age <span class="op">=</span> <span class="dv">122</span>
mass <span class="op">=</span> mass <span class="op">*</span> <span class="fl">2.0</span>
age <span class="op">=</span> age <span class="op">-</span> <span class="dv">20</span></code></pre></div>
</div>
</section>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="sorting-out-references-1"><span class="glyphicon glyphicon-pencil"></span>Sorting out references</h2>
</div>
<div class="panel-body">
<p>What does the following program print out?</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">first, second <span class="op">=</span> <span class="st">&#39;Grace&#39;</span>, <span class="st">&#39;Hopper&#39;</span>
third, fourth <span class="op">=</span> second, first
<span class="bu">print</span> third, fourth</code></pre></div>
</div>
</section>
<h2 id="slicing">Slicing</h2>
<p>A command like <code>topo[0,0]</code> selects a single element in the array <code>topo</code>. Indices can also be used to <a href="reference.html#slice">slice</a> sections of the array. For example, we can select the top left quarter of the array like this:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span> topo[<span class="dv">0</span>:<span class="dv">5</span>, <span class="dv">0</span>:<span class="dv">5</span>]</code></pre></div>
<pre class="output"><code>[[ 3198.8391  3198.123   3197.1584  3196.2017  3193.8813] [
    3198.3306  3197.5242  3196.4102  3194.7559  3191.9763] [ 3197.9968 
    3196.9197  3195.7188  3193.3855  3190.5371] [ 3198.054   3196.7031 
    3194.9573  3192.4451  3189.5288] [ 3198.3289  3196.9111  3195.335  
    3192.7874  3190.0085]]
</code></pre>
<p>The slice <code>[0:5]</code> means “Start at index 0 and go along the axis up to, but not including, index 5”.</p>
<p>We don’t need to include the upper or lower bound of the slice if we want to go all the way to the edge. If we don’t include the lower bound, Python uses 0 by default; if we don’t include the upper bound, the slice runs to the end of the axis. If we don’t include either (i.e., if we just use ‘:’), the slice includes everything:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span> topo[:<span class="bu">len</span>(topo)<span class="op">/</span><span class="dv">2</span>, <span class="bu">len</span>(topo)<span class="op">/</span><span class="dv">2</span>:]</code></pre></div>
<pre class="output"><code>[[ 3008.1116  3012.2922  3015.3018 ...,  2583.3293  2585.4368 
    2589.1079] [ 3009.9558  3014.0007  3016.5647 ...,  2582.6992 
    2584.9167  2587.801 ] [ 3010.8604  3014.1228  3016.7412 ..., 
    2581.8328  2583.8159  2586.0325] ..., [ 3370.0918  3368.5371 
    3366.7148 ...,  2687.8396  2682.4326  2676.8521] [ 3370.478  
    3368.7561  3366.8923 ...,  2685.9941  2681.2888  2676.9924] [
    3371.2021  3369.3376  3367.3677 ...,  2687.7014  2685.5146 
    2683.1936]]</code></pre>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="point-elevations"><span class="glyphicon glyphicon-pencil"></span>Point elevations</h2>
</div>
<div class="panel-body">
<p>Use indexing to answer the following questions and check your answers against the data visualization:</p>
<ul>
<li>Is the NW corner of the region higher than the SW corner? What’s the elevation difference?</li>
<li>What’s the elevation difference between the NE corner and the SE corner?</li>
<li>What’s the elevation at the center of the region shown in the array?</li>
</ul>
</div>
</section>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="slicing-strings"><span class="glyphicon glyphicon-pencil"></span>Slicing strings</h2>
</div>
<div class="panel-body">
<p>Indexing and slicing behave the same way for any type of sequence, including numpy arrays, lists, and strings. Create a new variable called <code>text</code> and assign it the string “The quick brown fox jumped over the lazy dog.” (note capitalization and punctuation and include the quotes so Python recognizes it as a string). Then use slicing and the <code>print</code> statement to create these sentences:</p>
<ul>
<li>the lazy dog.</li>
<li>The fox jumped over the dog</li>
<li>The lazy fox jumped over the quick brown dog.</li>
</ul>
</div>
</section>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="plotting-smaller-regions"><span class="glyphicon glyphicon-pencil"></span>Plotting smaller regions</h2>
</div>
<div class="panel-body">
<p>Use the function <code>imshow</code> from <code>matplotlib.pyplot</code> to make one plot showing the northern half of the region and another showing the southern half.</p>
<p>Next try making four separate plots showing each quarter of the region separately.</p>
</div>
</section>
<aside class="callout panel panel-info">
<div class="panel-heading">
<h2 id="integers-and-floats"><span class="glyphicon glyphicon-pushpin"></span>Integers and floats</h2>
</div>
<div class="panel-body">
<p>In the real world, dividing an odd number by 2 results in a number with a decimal point (ie. half of 7 is 3.5). In Python, though, that’s not always the case:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span> <span class="st">&#39;7/2 =&#39;</span>, <span class="dv">7</span><span class="op">/</span><span class="dv">2</span></code></pre></div>
<pre class="output"><code>7/2 = 3</code></pre>
<p>In Python 2.x, dividing one whole number (the number 7) by another whole number (the number 2) always results in a whole number. If either number is a decimal, division behaves as expected and returns a decimal:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span> <span class="st">&#39;7.0000000001/2 =&#39;</span>, <span class="fl">7.0000000001</span><span class="op">/</span><span class="dv">2</span></code></pre></div>
<pre class="output"><code>7.0000000001/2 = 3.50000000005</code></pre>
<p>For computers, integers (whole numbers) and floats (or floating point numbers, decimals) are object of different <a href="reference.html#type">type</a> and sometimes behave differently:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span> <span class="st">&#39;7 is an integer:&#39;</span>, <span class="bu">type</span>(<span class="dv">7</span>)
<span class="bu">print</span> <span class="st">&#39;7.0000000001 is a float:&#39;</span>, <span class="bu">type</span>(<span class="fl">7.0000000001</span>)</code></pre></div>
<pre class="output"><code>7 is an integer: &lt;type &#39;int&#39;&gt;
7.0000000001 is a float: &lt;type &#39;float&#39;&gt;</code></pre>
<p>While this might seem strange and unnecessarily annoying, some programming languages use integer division for historical reasons: integers take up less space in memory and integer operations were much faster on early machines. This behavior can easily introduce bugs into your code but it is actually useful in a lot of situations (Python 3.x does not use integer division by default but returns a float when appropriate).</p>
<p>Whole numbers are treated as floats if they have decimal point:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span> <span class="st">&#39;7 is&#39;</span>, <span class="bu">type</span>(<span class="dv">7</span>)
<span class="bu">print</span> <span class="st">&#39;-&#39;</span> <span class="op">*</span> <span class="dv">20</span>
<span class="bu">print</span> <span class="st">&#39;7. is&#39;</span>, <span class="bu">type</span>(<span class="dv">7</span>.)
<span class="bu">print</span> <span class="st">&#39;7.0 is&#39;</span>, <span class="bu">type</span>(<span class="fl">7.0</span>)</code></pre></div>
<pre class="output"><code>7 is &lt;type &#39;int&#39;&gt;
--------------------
7. is &lt;type &#39;float&#39;&gt;
7.0 is &lt;type &#39;float&#39;&gt;</code></pre>
<p>The integer assigned to a variable can be used as a float through <strong>casting</strong>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">type_int <span class="op">=</span> <span class="dv">7</span>
type_float <span class="op">=</span> <span class="bu">float</span>(type_int)

<span class="bu">print</span> <span class="st">&#39;type_int is&#39;</span>, <span class="bu">type</span>(type_int)
<span class="bu">print</span> <span class="st">&#39;float(type_int) is&#39;</span>,
<span class="bu">type</span>(type_float)</code></pre></div>
<pre class="output"><code>type_int is &lt;type &#39;int&#39;&gt;
float(type_int) is &lt;type &#39;float&#39;&gt;</code></pre>
<p>Casting doesn’t permanently change the value of the original object, though:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span> <span class="st">&#39;type_int/2 =&#39;</span>, type_int<span class="op">/</span><span class="dv">2</span>
<span class="bu">print</span> <span class="st">&#39;float(type_int)/2 =&#39;</span>, <span class="bu">float</span>(type_int)<span class="op">/</span><span class="dv">2</span></code></pre></div>
<pre class="output"><code>type_int/2 = 3
float(type_int)/2 = 3.5</code></pre>
</div>
</aside>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="non-square-arrays"><span class="glyphicon glyphicon-pencil"></span>Non-square arrays</h2>
</div>
<div class="panel-body">
<p>We’ve been using <code>len(topo)/2</code> as both the row and column indices of the center point in the array <code>topo</code>. This doesn’t work with an array that’s not square (has different height and width).</p>
<ul>
<li><p>Take a (small) slice of the array <code>topo</code> and assign it to a new variable. Make this new array have a height longer than its width, and make both the height and width even numbers (4 x 6 is a good size).</p></li>
<li><p>Access the center point of your new array. Write the indices using variables, not numbers (ie. don’t write <code>t[2,3]</code>) (Hint: <code>topo.shape</code> gives the number of rows and columns in <code>topo</code>. The function <code>len(topo)</code> returns the length of the longest axis. Instead of using <code>len()</code>, assign the output of <code>shape</code> to a variable and use indexing). Are you <em>really</em> pointing to the center of your array? How far off are you?</p></li>
</ul>
</div>
</section>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="odd-sized-arrays"><span class="glyphicon glyphicon-pencil"></span>Odd-sized arrays</h2>
</div>
<div class="panel-body">
<p>Both the array <code>topo</code> and the one you created above have even numbers of rows and columns. In that case, the output of <code>width/2</code> and <code>height/2</code> were both whole numbers (and therefore valid indices). <em>Mysteriously</em>, <code>len(topo)/2</code> would work as an index even if the array <code>topo</code> had odd numbers of rows and columns. Let’s test it out!</p>
<ul>
<li><p>Take a second slice of <code>topo</code> that is one row and column larger than the one you made previously. Check its shape and print the value at the center of the array using indices like <code>width/2</code> and <code>height/2</code>. Does this work? <em>Should</em> this work?</p></li>
<li><p>Compare the actual indices of the center point of this array and the indices you would calculate by dividing its width and height by 2. Is division in Python behaving like division in the real world? (Hint: If an array has a width and height that are odd numbers, what should the value of <code>width/2</code> be?).</p></li>
<li><p>Test the behavior of division (using <code>/</code>) in Python by trying various even and odd whole numbers and decimals as both the nominator and denominator.</p></li>
</ul>
</div>
</section>
<h2 id="numerical-operations-on-arrays">Numerical operations on arrays</h2>
<p>We can perform basic mathematical operations on each individual element of a NumPy array. We can create a new array with elevations in feet:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">topo_in_feet <span class="op">=</span> topo <span class="op">*</span> <span class="fl">3.2808</span>
<span class="bu">print</span> <span class="st">&#39;Elevation in meters:&#39;</span>, topo[<span class="dv">0</span>,<span class="dv">0</span>]
<span class="bu">print</span> <span class="st">&#39;Elevation in feet:&#39;</span>, topo_in_feet[<span class="dv">0</span>,<span class="dv">0</span>]</code></pre></div>
<pre class="output"><code>Elevation in meters: 3198.8391
Elevation in feet: 10494.7513193</code></pre>
<p>Arrays of the same size can be used together in arithmatic operations:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">double_topo <span class="op">=</span> topo <span class="op">+</span> topo
<span class="bu">print</span> <span class="st">&#39;Double topo:&#39;</span>, double_topo[<span class="dv">0</span>,<span class="dv">0</span>], <span class="st">&#39;meters&#39;</span></code></pre></div>
<pre class="output"><code>Double topo: 6397.6782 meters</code></pre>
<p>We can also perform statistical operations on arrays:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span> <span class="st">&#39;Mean elevation:&#39;</span>, topo.mean(), <span class="st">&#39;meters&#39;</span></code></pre></div>
<pre class="output"><code>Mean elevation: 3153.62166407 meters</code></pre>
<aside class="callout panel panel-info">
<div class="panel-heading">
<h2 id="methods-vs.attributes"><span class="glyphicon glyphicon-pushpin"></span>Methods vs. attributes</h2>
</div>
<div class="panel-body">
<p><code>mean</code> is a method that belongs to the array <code>topo</code>, i.e., it is a function that belongs to <code>topo</code> just like the attribute <code>shape</code> does. When we call <code>topo.mean()</code>, we are asking <code>topo</code> to calculate its mean value. Because it is a function, we need to include parenthesis in the command. A call to <code>topo.shape</code> doesn’t include parenthesis because attributes are objects, not functions.</p>
<p>Python will kindly tell us if we mix up the parentheses:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">topo.mean</code></pre></div>
<pre class="output"><code>&lt;function mean&gt;</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">topo.shape()</code></pre></div>
<pre class="output"><code>--------------------------------------------------------------------
-------

TypeError                                 Traceback (most recent
call last)

&lt;ipython-input-29-5f3a6f1ecafc&gt; in &lt;module&gt;() ----&gt; 1 topo.shape()

TypeError: &#39;tuple&#39; object is not callable</code></pre>
</div>
</aside>
<p>NumPy arrays have many other useful methods:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span> <span class="st">&#39;Highest elevation:&#39;</span>, topo.<span class="bu">max</span>(), <span class="st">&#39;meters&#39;</span>
<span class="bu">print</span> <span class="st">&#39;Lowest elevation:&#39;</span>, topo.<span class="bu">min</span>(), <span class="st">&#39;meters&#39;</span> </code></pre></div>
<pre class="output"><code>Highest elevation: 3831.2617 meters
Lowest elevation: 2565.0293 meters</code></pre>
<p>We can also call methods on slices of the array:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">half_len <span class="op">=</span> <span class="bu">int</span>(<span class="bu">len</span>(topo) <span class="op">/</span> <span class="dv">2</span>)

<span class="bu">print</span> <span class="st">&#39;Highest elevation of NW quarter:&#39;</span>, topo[:half_len,
:half_len].<span class="bu">max</span>(), <span class="st">&#39;meters&#39;</span>

<span class="bu">print</span> <span class="st">&#39;Highest elevation of SE quarter:&#39;</span>, topo[half_len:,
half_len:].<span class="bu">max</span>(), <span class="st">&#39;meters&#39;</span> </code></pre></div>
<pre class="output"><code>Highest elevation of NW quarter: 3600.709 meters
Highest elevation of SE quarter: 3575.3262 meters</code></pre>
<p>Methods can also be used along individual axes (rows or columns) of an array. If we want to see how the mean elevation changes with longitude (E-W), we can use the method along <code>axis=0</code>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span> topo.mean(axis<span class="op">=</span><span class="dv">0</span>) </code></pre></div>
<p>To see how the mean elevation changes with latitude (N-S), we can use <code>axis=1</code>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span> topo.mean(axis<span class="op">=</span><span class="dv">1</span>) </code></pre></div>
<h2 id="plotting-take-two">Plotting, take two</h2>
<p>It’s hard to get a sense of how the topography changes across the landscape from these big tables of numbers. A simpler way to display this information is with line plots.</p>
<p>We are again going to use the <code>matplotlib</code> package for data visualization. Since we imported the <code>matplotlib.pyplot</code> library once already, those tools are available and can be called within Python. As a review, though, we are going to write every step needed to load and plot the data.</p>
<p>We use the function <code>plot</code> to create two basic line plots of the topography:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy <span class="im">as</span> np
<span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt
<span class="op">%</span>matplotlib inline

topo <span class="op">=</span> np.loadtxt(<span class="st">&#39;topo.asc&#39;</span>, delimiter<span class="op">=</span><span class="st">&#39;,&#39;</span>)

plt.plot(topo[<span class="dv">0</span>,:])
plt.title(<span class="st">&#39;Topographic profile, northern edge&#39;</span>)
plt.ylabel(<span class="st">&#39;Elevation (m)&#39;</span>)
plt.xlabel(<span class="st">&#39;&lt;-- West    East --&gt;&#39;</span>)
plt.show()

plt.plot(topo[<span class="op">-</span><span class="dv">1</span>,:], <span class="st">&#39;r--&#39;</span>)
plt.title(<span class="st">&#39;Topographic profile, southern edge&#39;</span>)
plt.ylabel(<span class="st">&#39;Elevation (m)&#39;</span>)
plt.xlabel(<span class="st">&#39;&lt;-- West    East --&gt;&#39;</span>)
plt.show() </code></pre></div>
<pre class="output"><code>![png](output_74_0.png)
![png](output_74_1.png)</code></pre>
<aside class="callout panel panel-info">
<div class="panel-heading">
<h2 id="scientists-dislike-typing"><span class="glyphicon glyphicon-pushpin"></span>Scientists dislike typing</h2>
</div>
<div class="panel-body">
<p>We will always use the syntax <code>import numpy</code> to import NumPy. However, in order to save typing, it is <a href="http://www.scipy.org/getting-started.html#an-example-script">often suggested</a> to make a shortcut like so: <code>import numpy as np</code>. If you ever see Python code using a NumPy function with <code>np</code> (for example, <code>np.loadtxt(...)</code>), it’s because they’ve used this shortcut.</p>
</div>
</aside>
<p>To better compare these profiles, we can plot them as separate lines in a single figure using the argument <code>hold=True</code>, This will force all subsequent calls to <code>plt.plot</code> to use the same axes (until it reaches <code>plt.show()</code>). The argument <code>label=</code> holds the label that will appear in the legend.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy <span class="im">as</span> np <span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt
<span class="op">%</span>matplotlib inline

topo <span class="op">=</span> np.loadtxt(<span class="st">&#39;topo.asc&#39;</span>, delimiter<span class="op">=</span><span class="st">&#39;,&#39;</span>)

plt.plot(topo[<span class="dv">0</span>,:], hold<span class="op">=</span><span class="va">True</span>, label<span class="op">=</span><span class="st">&#39;North&#39;</span>)

plt.plot(topo[<span class="op">-</span><span class="dv">1</span>,:], <span class="st">&#39;r--&#39;</span>, label<span class="op">=</span><span class="st">&#39;South&#39;</span>)

plt.plot(topo[<span class="bu">len</span>(topo)<span class="op">/</span><span class="dv">2</span>,:], <span class="st">&#39;g:&#39;</span>, linewidth<span class="op">=</span><span class="dv">3</span>, label<span class="op">=</span><span class="st">&#39;Mid&#39;</span>)

plt.title(<span class="st">&#39;Topographic profiles&#39;</span>)
plt.ylabel(<span class="st">&#39;Elevation (m)&#39;</span>)
plt.xlabel(<span class="st">&#39;&lt;-- West    East --&gt;&#39;</span>)
plt.legend(loc <span class="op">=</span> <span class="st">&#39;lower left&#39;</span>)

plt.show() </code></pre></div>
<pre class="output"><code>![png](output_77_0.png)</code></pre>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="make-your-own-plots"><span class="glyphicon glyphicon-pencil"></span>Make your own plots</h2>
</div>
<div class="panel-body">
<p>Create three separate plots showing how the maximum (<code>numpy.max()</code>), minimum (<code>numpy.min()</code>), and mean (<code>numpy.mean()</code>) elevation changes with longitude. Label the axes and include a title for each of the plots (Hint: use <code>axis=0</code>).</p>
<p>Convert the separate plots into a single plot that includes all three statistics (using <code>hold=True</code>). Create a legend.</p>
</div>
</section>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="subplots"><span class="glyphicon glyphicon-pencil"></span>Subplots</h2>
</div>
<div class="panel-body">
<p>We often want to arrange separate plots in layouts with multiple rows and columns. The script below uses subplots to show the elevation profile at the western edge, the mid longitude, and eastern edge of the region. Subplots can be a little weird because they require the axes to be defined before plotting. Type (don’t copy-past!) the code below to get a sense of how it works.</p>
<p>This script uses a number of new commands. The function <code>plt.figure()</code> creates a space into which we will place the three plots. The parameter <code>figsize</code> tells Python how big to make this space. Each subplot is placed into the figure using the <code>subplot</code> command. The <code>subplot</code> command takes 3 parameters: the first denotes the total number of rows of subplots in the figure, the second is the total number of columns of subplots in the figure, and the final parameters identifies the position of the subplot in the grid. The axes of each subplot are called with different variable (axes1, axes2, axes3, axes4). Once a subplot is created, the axes can be labeled using the <code>set_xlabel()</code> (or <code>set_ylabel()</code>) method. <code>plt.show()</code> is called after the entire figure is set up.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy <span class="im">as</span> np <span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt
<span class="op">%</span>matplotlib inline

topo <span class="op">=</span> np.loadtxt(<span class="st">&#39;topo.asc&#39;</span>, delimiter<span class="op">=</span><span class="st">&#39;,&#39;</span>)

fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="fl">16.0</span>, <span class="fl">3.0</span>))

axes1 <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">1</span>)
axes2 <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>)
axes3 <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">3</span>)

axes1.plot(topo[:,<span class="dv">0</span>])
axes1.set_ylim([<span class="dv">2500</span>,<span class="dv">3900</span>])
axes1.set_ylabel(<span class="st">&#39;Elevation (m)&#39;</span>)
axes1.set_xlabel(<span class="st">&#39;&lt;-- N   S --&gt;&#39;</span>)
axes1.set_title(<span class="st">&#39;West&#39;</span>)

axes2.plot(topo[:,<span class="bu">len</span>(topo)<span class="op">/</span><span class="dv">2</span>])
axes2.set_ylim([<span class="dv">2500</span>,<span class="dv">3900</span>])
axes2.set_xlabel(<span class="st">&#39;&lt;-- N   S --&gt;&#39;</span>)
axes2.set_title(<span class="st">&#39;Mid&#39;</span>)

axes3.plot(topo[:,<span class="op">-</span><span class="dv">1</span>])
axes3.set_ylim([<span class="dv">2500</span>,<span class="dv">3900</span>])
axes3.set_xlabel(<span class="st">&#39;&lt;--N   S --&gt;&#39;</span>)
axes3.set_title(<span class="st">&#39;East&#39;</span>)

plt.show(fig) </code></pre></div>
<pre class="output"><code>![png](output_80_0.png)</code></pre>
</div>
</section>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="subplots-of-dems"><span class="glyphicon glyphicon-pencil"></span>Subplots of DEMs</h2>
</div>
<div class="panel-body">
<p>Make a 2x2 grid of subplots that use the function <code>imshow</code> to display each quarter of the dataset (ie. split down the middle in both x and y).</p>
<ul>
<li>Don’t label axes or add a colorbar. It can be tricky to do this with subplots.</li>
<li>To set the range of colors for one subplot, include the arguments <code>vmin</code> and <code>vmax</code> in <code>imshow</code> like this:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">vmin <span class="op">=</span> topo.<span class="bu">min</span>()
vmax <span class="op">=</span> topo.<span class="bu">max</span>()

plt.imshow(topo, vmin<span class="op">=</span>vmin, vmax<span class="op">=</span>vmax) </code></pre></div>
<pre class="output"><code>![png](output_82_1.png)</code></pre>
</div>
</section>
        </div>
      </div>
      </article>
      <div class="footer">
        <a class="label swc-blue-bg" href="http://csdms.colorado.edu">CSDMS</a>
        <a class="label swc-blue-bg" href="https://github.com/mperignon/2016-05-16-csdms/">Source</a>
        <a class="label swc-blue-bg" href="mailto:perignon@colorado.edu">Contact</a>
        <a class="label swc-blue-bg" href="LICENSE.html">License</a>
      </div>
    </div>
    <!-- Javascript placed at the end of the document so the pages load faster -->
    <script src="http://software-carpentry.org/v5/js/jquery-1.9.1.min.js"></script>
    <script src="css/bootstrap/bootstrap-js/bootstrap.js"></script>
  </body>
</html>
